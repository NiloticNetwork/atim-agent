#!/usr/bin/env python3

import os
import re
import json
import time
import jwt
import requests
from datetime import datetime
from typing import List, Dict, Optional
from dataclasses import dataclass, asdict
from dotenv import load_dotenv

@dataclass
class IssueProposal:
    id: str
    title: str
    description: str
    severity: str  # 'low', 'medium', 'high', 'critical'
    category: str  # 'bug', 'enhancement', 'security', 'performance', 'documentation'
    file_path: Optional[str] = None
    line_number: Optional[int] = None
    suggested_fix: Optional[str] = None
    labels: List[str] = None
    created_at: str = None
    status: str = 'pending'  # 'pending', 'approved', 'rejected', 'published'
    github_issue_number: Optional[int] = None
    
    def __post_init__(self):
        if self.labels is None:
            self.labels = []
        if self.created_at is None:
            self.created_at = datetime.now().isoformat()

class GitHubIntegrationSimple:
    """Simplified GitHub integration using direct API calls"""
    
    def __init__(self, repo_name: str = None):
        load_dotenv()
        
        # GitHub App credentials
        self.app_id = os.environ.get('GITHUB_APP_ID')
        self.private_key_path = os.environ.get('GITHUB_APP_PRIVATE_KEY_PATH')
        self.repo_name = repo_name or os.environ.get('GITHUB_REPO', 'NiloticNetwork/NiloticNetworkBlockchain')
        
        # App configuration
        self.app_name = "Atim AI Assistant"
        self.app_description = "AI-powered blockchain development assistant for the Nilotic Network"
        self.app_signature = "🤖 *Generated by Atim AI Assistant*"
        
        # API configuration
        self.base_url = "https://api.github.com"
        self.headers = {}
        
        # Initialize GitHub App authentication
        self._initialize_github_app()
        
    def _initialize_github_app(self):
        """Initialize GitHub App authentication"""
        if not all([self.app_id, self.private_key_path]):
            print("⚠️  GitHub App credentials not fully configured.")
            print("   Required: GITHUB_APP_ID, GITHUB_APP_PRIVATE_KEY_PATH")
            return
            
        try:
            # Generate JWT for app authentication
            jwt_token = self._generate_jwt()
            
            # Set headers for app-level API calls
            app_headers = {
                'Authorization': f'Bearer {jwt_token}',
                'Accept': 'application/vnd.github.v3+json',
                'User-Agent': 'Atim-AI-Assistant/1.0'
            }
            
            # Test app authentication
            response = requests.get(f"{self.base_url}/app", headers=app_headers)
            if response.status_code == 200:
                app_data = response.json()
                print(f"🤖 Atim GitHub App authenticated successfully")
                print(f"✅ App name: {app_data.get('name', 'Unknown')}")
                
                # Get installation access token for repository access
                self._get_installation_token(app_headers)
            else:
                print(f"❌ GitHub App authentication failed: {response.status_code}")
                print(f"   Response: {response.text}")
                self.headers = {}
                
        except Exception as e:
            print(f"❌ Atim GitHub App authentication failed: {e}")
            self.headers = {}
    
    def _get_installation_token(self, app_headers):
        """Get installation access token for repository access"""
        try:
            # First, find the installation for the repository
            response = requests.get(f"{self.base_url}/app/installations", headers=app_headers)
            
            if response.status_code == 200:
                installations = response.json()
                
                # Find installation for our repository
                target_installation = None
                for installation in installations:
                    if installation.get('account', {}).get('login') == self.repo_name.split('/')[0]:
                        target_installation = installation
                        break
                
                if target_installation:
                    installation_id = target_installation['id']
                    print(f"✅ Found installation ID: {installation_id}")
                    
                    # Get installation access token
                    token_response = requests.post(
                        f"{self.base_url}/app/installations/{installation_id}/access_tokens",
                        headers=app_headers
                    )
                    
                    if token_response.status_code == 201:
                        token_data = token_response.json()
                        access_token = token_data['token']
                        
                        # Set headers for repository access
                        self.headers = {
                            'Authorization': f'Bearer {access_token}',
                            'Accept': 'application/vnd.github.v3+json',
                            'User-Agent': 'Atim-AI-Assistant/1.0'
                        }
                        
                        print(f"✅ Installation token generated successfully")
                        print(f"✅ App can access repository: {self.repo_name}")
                    else:
                        print(f"❌ Failed to get installation token: {token_response.status_code}")
                        self.headers = {}
                else:
                    print(f"❌ No installation found for repository: {self.repo_name}")
                    print(f"   Please install the GitHub App on the repository")
                    self.headers = {}
            else:
                print(f"❌ Failed to get installations: {response.status_code}")
                self.headers = {}
                
        except Exception as e:
            print(f"❌ Error getting installation token: {e}")
            self.headers = {}
    
    def _generate_jwt(self) -> str:
        """Generate JWT for GitHub App authentication"""
        try:
            with open(self.private_key_path, 'r') as f:
                private_key = f.read()
            
            payload = {
                'iat': int(time.time()),
                'exp': int(time.time()) + 600,  # 10 minutes
                'iss': int(self.app_id)
            }
            
            return jwt.encode(payload, private_key, algorithm='RS256')
            
        except Exception as e:
            raise Exception(f"Failed to generate JWT: {e}")
    
    def create_issue(self, title: str, body: str, labels: List[str] = None) -> Dict:
        """Create a GitHub issue"""
        if not self.headers:
            return {"error": "GitHub App not authenticated"}
        
        try:
            data = {
                "title": title,
                "body": f"{body}\n\n{self.app_signature}",
                "labels": labels or []
            }
            
            response = requests.post(
                f"{self.base_url}/repos/{self.repo_name}/issues",
                headers=self.headers,
                json=data
            )
            
            if response.status_code == 201:
                issue_data = response.json()
                print(f"✅ Issue created successfully: #{issue_data['number']}")
                return issue_data
            else:
                print(f"❌ Failed to create issue: {response.status_code}")
                print(f"   Response: {response.text}")
                return {"error": f"Failed to create issue: {response.status_code}"}
                
        except Exception as e:
            print(f"❌ Error creating issue: {e}")
            return {"error": str(e)}
    
    def get_repository_contents(self, path: str = "") -> List[Dict]:
        """Get repository contents"""
        if not self.headers:
            return []
        
        try:
            response = requests.get(
                f"{self.base_url}/repos/{self.repo_name}/contents/{path}",
                headers=self.headers
            )
            
            if response.status_code == 200:
                return response.json()
            else:
                print(f"❌ Failed to get repository contents: {response.status_code}")
                return []
                
        except Exception as e:
            print(f"❌ Error getting repository contents: {e}")
            return []
    
    def analyze_repository(self) -> List[IssueProposal]:
        """Analyze the repository and generate issue proposals"""
        if not self.headers:
            return self._generate_sample_proposals()
        
        proposals = []
        
        # Analyze different aspects of the codebase
        proposals.extend(self._analyze_security_issues())
        proposals.extend(self._analyze_performance_issues())
        proposals.extend(self._analyze_code_quality_issues())
        proposals.extend(self._analyze_documentation_issues())
        proposals.extend(self._analyze_architecture_issues())
        
        return proposals
    
    def _analyze_security_issues(self) -> List[IssueProposal]:
        """Analyze potential security issues"""
        proposals = []
        
        # Check for common security patterns
        security_patterns = [
            {
                'pattern': r'strcpy\s*\(',
                'title': 'Use of unsafe strcpy function',
                'description': 'The code uses strcpy which is vulnerable to buffer overflows. Consider using strncpy or std::string.',
                'severity': 'high',
                'category': 'security',
                'labels': ['security', 'bug']
            },
            {
                'pattern': r'sprintf\s*\(',
                'title': 'Use of unsafe sprintf function',
                'description': 'sprintf is vulnerable to buffer overflows. Use snprintf or std::string formatting.',
                'severity': 'high',
                'category': 'security',
                'labels': ['security', 'bug']
            },
            {
                'pattern': r'rand\s*\(',
                'title': 'Use of predictable random number generation',
                'description': 'rand() is not cryptographically secure. Use std::random_device or crypto-secure RNG for cryptographic operations.',
                'severity': 'medium',
                'category': 'security',
                'labels': ['security', 'enhancement']
            }
        ]
        
        # For now, return sample security issues
        proposals.append(IssueProposal(
            id=str(len(proposals) + 1),
            title="Potential buffer overflow in string handling",
            description="The codebase contains instances of unsafe string operations that could lead to buffer overflows. Consider implementing safer alternatives.",
            severity="high",
            category="security",
            labels=["security", "bug", "critical"]
        ))
        
        return proposals
    
    def _analyze_performance_issues(self) -> List[IssueProposal]:
        """Analyze potential performance issues"""
        proposals = []
        
        proposals.append(IssueProposal(
            id=str(len(proposals) + 1),
            title="Optimize blockchain validation performance",
            description="The current validation algorithm could be optimized for better performance with large transaction volumes.",
            severity="medium",
            category="performance",
            labels=["performance", "enhancement"]
        ))
        
        return proposals
    
    def _analyze_code_quality_issues(self) -> List[IssueProposal]:
        """Analyze code quality issues"""
        proposals = []
        
        proposals.append(IssueProposal(
            id=str(len(proposals) + 1),
            title="Improve error handling in transaction processing",
            description="Add more comprehensive error handling and logging for better debugging and reliability.",
            severity="medium",
            category="enhancement",
            labels=["enhancement", "code-quality"]
        ))
        
        return proposals
    
    def _analyze_documentation_issues(self) -> List[IssueProposal]:
        """Analyze documentation issues"""
        proposals = []
        
        proposals.append(IssueProposal(
            id=str(len(proposals) + 1),
            title="Add comprehensive API documentation",
            description="The blockchain API lacks comprehensive documentation. Consider adding detailed API docs with examples.",
            severity="low",
            category="documentation",
            labels=["documentation", "enhancement"]
        ))
        
        return proposals
    
    def _analyze_architecture_issues(self) -> List[IssueProposal]:
        """Analyze architecture issues"""
        proposals = []
        
        proposals.append(IssueProposal(
            id=str(len(proposals) + 1),
            title="Implement modular blockchain architecture",
            description="Consider refactoring the blockchain into more modular components for better maintainability.",
            severity="medium",
            category="enhancement",
            labels=["architecture", "enhancement"]
        ))
        
        return proposals
    
    def _generate_sample_proposals(self) -> List[IssueProposal]:
        """Generate sample issue proposals when GitHub integration is not available"""
        return [
            IssueProposal(
                id="1",
                title="Fix supply calculation bug",
                description="The total supply calculation is incorrect. It should include premined tokens and block rewards.",
                severity="high",
                category="bug",
                labels=["bug", "critical"]
            ),
            IssueProposal(
                id="2",
                title="Add getCurrentSupply() method",
                description="Implement a method to accurately calculate and return the current circulating supply.",
                severity="medium",
                category="enhancement",
                labels=["enhancement", "feature"]
            ),
            IssueProposal(
                id="3",
                title="Fix race condition in transaction validation",
                description="There's a potential race condition when multiple transactions are validated simultaneously.",
                severity="high",
                category="bug",
                labels=["bug", "security"]
            ),
            IssueProposal(
                id="4",
                title="Improve validation error messages",
                description="Make validation error messages more descriptive and user-friendly.",
                severity="low",
                category="enhancement",
                labels=["enhancement", "ux"]
            )
        ]
    
    def create_github_issue(self, proposal: IssueProposal) -> Optional[int]:
        """Create a GitHub issue from a proposal"""
        if not self.headers:
            print("❌ GitHub App not authenticated")
            return None
        
        try:
            result = self.create_issue(
                title=proposal.title,
                body=proposal.description,
                labels=proposal.labels
            )
            
            if "error" not in result:
                return result.get('number')
            else:
                print(f"❌ Failed to create issue: {result['error']}")
                return None
                
        except Exception as e:
            print(f"❌ Error creating GitHub issue: {e}")
            return None
    
    def get_repository_stats(self) -> Dict:
        """Get repository statistics"""
        if not self.headers:
            return {
                'error': 'GitHub App not authenticated',
                'repository': self.repo_name,
                'issues_count': 0,
                'pull_requests_count': 0,
                'stars_count': 0,
                'forks_count': 0,
                'last_updated': None
            }
        
        try:
            # Get repository information
            response = requests.get(
                f"{self.base_url}/repos/{self.repo_name}",
                headers=self.headers
            )
            
            if response.status_code == 200:
                repo_data = response.json()
                
                # Get issues count
                issues_response = requests.get(
                    f"{self.base_url}/repos/{self.repo_name}/issues",
                    headers=self.headers,
                    params={'state': 'open', 'per_page': 1}
                )
                
                issues_count = 0
                if issues_response.status_code == 200:
                    # Get total count from Link header if available
                    link_header = issues_response.headers.get('Link', '')
                    if 'rel="last"' in link_header:
                        # Extract page number from last link
                        import re
                        match = re.search(r'page=(\d+)>; rel="last"', link_header)
                        if match:
                            issues_count = int(match.group(1))
                
                # Get pull requests count
                pr_response = requests.get(
                    f"{self.base_url}/repos/{self.repo_name}/pulls",
                    headers=self.headers,
                    params={'state': 'open', 'per_page': 1}
                )
                
                pr_count = 0
                if pr_response.status_code == 200:
                    link_header = pr_response.headers.get('Link', '')
                    if 'rel="last"' in link_header:
                        import re
                        match = re.search(r'page=(\d+)>; rel="last"', link_header)
                        if match:
                            pr_count = int(match.group(1))
                
                return {
                    'repository': repo_data.get('full_name', self.repo_name),
                    'description': repo_data.get('description', 'No description'),
                    'issues_count': issues_count,
                    'pull_requests_count': pr_count,
                    'stars_count': repo_data.get('stargazers_count', 0),
                    'forks_count': repo_data.get('forks_count', 0),
                    'last_updated': repo_data.get('updated_at'),
                    'default_branch': repo_data.get('default_branch', 'main'),
                    'language': repo_data.get('language', 'Unknown'),
                    'size': repo_data.get('size', 0)
                }
            else:
                return {
                    'error': f'Failed to get repository data: {response.status_code}',
                    'repository': self.repo_name,
                    'issues_count': 0,
                    'pull_requests_count': 0,
                    'stars_count': 0,
                    'forks_count': 0,
                    'last_updated': None
                }
                
        except Exception as e:
            return {
                'error': f'Error getting repository stats: {str(e)}',
                'repository': self.repo_name,
                'issues_count': 0,
                'pull_requests_count': 0,
                'stars_count': 0,
                'forks_count': 0,
                'last_updated': None
            }
