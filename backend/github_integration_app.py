#!/usr/bin/env python3

import os
import re
import json
import time
import jwt
import requests
from datetime import datetime
from typing import List, Dict, Optional
from github import Github, GithubException
from github.Auth import AppAuth
from dataclasses import dataclass, asdict
from dotenv import load_dotenv

@dataclass
class IssueProposal:
    id: str
    title: str
    description: str
    severity: str  # 'low', 'medium', 'high', 'critical'
    category: str  # 'bug', 'enhancement', 'security', 'performance', 'documentation'
    file_path: Optional[str] = None
    line_number: Optional[int] = None
    suggested_fix: Optional[str] = None
    labels: List[str] = None
    created_at: str = None
    status: str = 'pending'  # 'pending', 'approved', 'rejected', 'published'
    github_issue_number: Optional[int] = None
    
    def __post_init__(self):
        if self.labels is None:
            self.labels = []
        if self.created_at is None:
            self.created_at = datetime.now().isoformat()

class GitHubIntegrationApp:
    """GitHub integration using GitHub App authentication"""
    
    def __init__(self, repo_name: str = None):
        load_dotenv()
        
        # GitHub App credentials
        self.app_id = os.environ.get('GITHUB_APP_ID')
        self.private_key_path = os.environ.get('GITHUB_APP_PRIVATE_KEY_PATH')
        self.client_id = os.environ.get('GITHUB_APP_CLIENT_ID')
        self.client_secret = os.environ.get('GITHUB_APP_CLIENT_SECRET')
        self.repo_name = repo_name or os.environ.get('GITHUB_REPO', 'NiloticNetwork/NiloticNetworkBlockchain')
        
        # App configuration
        self.app_name = "Atim AI Assistant"
        self.app_description = "AI-powered blockchain development assistant for the Nilotic Network"
        self.app_signature = "🤖 *Generated by Atim AI Assistant*"
        
        # Initialize GitHub client
        self.github = None
        self.repo = None
        self._initialize_github_app()
        
    def _initialize_github_app(self):
        """Initialize GitHub App authentication"""
        if not all([self.app_id, self.private_key_path]):
            print("⚠️  GitHub App credentials not fully configured.")
            print("   Required: GITHUB_APP_ID, GITHUB_APP_PRIVATE_KEY_PATH")
            return
            
        try:
            # Generate JWT for app authentication
            jwt_token = self._generate_jwt()
            
            # Initialize GitHub client with JWT token
            self.github = Github(auth=AppAuth(self.app_id, jwt_token))
            
            # Test repository access
            self.repo = self.github.get_repo(self.repo_name)
            print(f"🤖 Atim GitHub App authenticated successfully")
            print(f"✅ App can access repository: {self.repo.full_name}")
            
        except Exception as e:
            print(f"❌ Atim GitHub App authentication failed: {e}")
            self.github = None
            self.repo = None
    
    def _generate_jwt(self) -> str:
        """Generate JWT for GitHub App authentication"""
        try:
            with open(self.private_key_path, 'r') as f:
                private_key = f.read()
            
            payload = {
                'iat': int(time.time()),
                'exp': int(time.time()) + 600,  # 10 minutes
                'iss': int(self.app_id)
            }
            
            return jwt.encode(payload, private_key, algorithm='RS256')
            
        except Exception as e:
            raise Exception(f"Failed to generate JWT: {e}")
    

    
    def analyze_repository(self) -> List[IssueProposal]:
        """Analyze the repository and generate issue proposals"""
        if not self.repo:
            return self._generate_sample_proposals()
        
        proposals = []
        
        # Analyze different aspects of the codebase
        proposals.extend(self._analyze_security_issues())
        proposals.extend(self._analyze_performance_issues())
        proposals.extend(self._analyze_code_quality_issues())
        proposals.extend(self._analyze_documentation_issues())
        proposals.extend(self._analyze_architecture_issues())
        
        return proposals
    
    def _analyze_security_issues(self) -> List[IssueProposal]:
        """Analyze potential security issues"""
        proposals = []
        
        # Check for common security patterns
        security_patterns = [
            {
                'pattern': r'strcpy\s*\(',
                'title': 'Use of unsafe strcpy function',
                'description': 'The code uses strcpy which is vulnerable to buffer overflows. Consider using strncpy or std::string.',
                'severity': 'high',
                'category': 'security',
                'labels': ['security', 'bug']
            },
            {
                'pattern': r'sprintf\s*\(',
                'title': 'Use of unsafe sprintf function',
                'description': 'sprintf is vulnerable to buffer overflows. Use snprintf or std::string formatting.',
                'severity': 'high',
                'category': 'security',
                'labels': ['security', 'bug']
            },
            {
                'pattern': r'rand\s*\(',
                'title': 'Use of predictable random number generation',
                'description': 'rand() is not cryptographically secure. Use std::random_device or crypto-secure RNG for cryptographic operations.',
                'severity': 'medium',
                'category': 'security',
                'labels': ['security', 'enhancement']
            }
        ]
        
        try:
            contents = self.repo.get_contents("")
            for content_file in contents:
                if content_file.type == "file" and content_file.path.endswith(('.cpp', '.c', '.h', '.hpp')):
                    try:
                        file_content = content_file.decoded_content.decode('utf-8')
                        for pattern_info in security_patterns:
                            if re.search(pattern_info['pattern'], file_content):
                                proposals.append(IssueProposal(
                                    id=f"sec_{len(proposals) + 1}",
                                    title=pattern_info['title'],
                                    description=pattern_info['description'],
                                    severity=pattern_info['severity'],
                                    category=pattern_info['category'],
                                    file_path=content_file.path,
                                    labels=pattern_info['labels']
                                ))
                    except Exception as e:
                        print(f"Error analyzing file {content_file.path}: {e}")
        except Exception as e:
            print(f"Error accessing repository contents: {e}")
        
        return proposals
    
    def _analyze_performance_issues(self) -> List[IssueProposal]:
        """Analyze potential performance issues"""
        proposals = []
        
        performance_patterns = [
            {
                'pattern': r'std::vector.*\.push_back\s*\(',
                'title': 'Inefficient vector operations',
                'description': 'Consider reserving vector capacity before multiple push_back operations to avoid reallocations.',
                'severity': 'medium',
                'category': 'performance',
                'labels': ['performance', 'enhancement']
            },
            {
                'pattern': r'std::map.*\.find\s*\(',
                'title': 'Inefficient map lookups',
                'description': 'Consider using std::unordered_map for better performance if order is not required.',
                'severity': 'medium',
                'category': 'performance',
                'labels': ['performance', 'enhancement']
            }
        ]
        
        try:
            contents = self.repo.get_contents("")
            for content_file in contents:
                if content_file.type == "file" and content_file.path.endswith(('.cpp', '.c', '.h', '.hpp')):
                    try:
                        file_content = content_file.decoded_content.decode('utf-8')
                        for pattern_info in performance_patterns:
                            if re.search(pattern_info['pattern'], file_content):
                                proposals.append(IssueProposal(
                                    id=f"perf_{len(proposals) + 1}",
                                    title=pattern_info['title'],
                                    description=pattern_info['description'],
                                    severity=pattern_info['severity'],
                                    category=pattern_info['category'],
                                    file_path=content_file.path,
                                    labels=pattern_info['labels']
                                ))
                    except Exception as e:
                        print(f"Error analyzing file {content_file.path}: {e}")
        except Exception as e:
            print(f"Error accessing repository contents: {e}")
        
        return proposals
    
    def _analyze_code_quality_issues(self) -> List[IssueProposal]:
        """Analyze code quality issues"""
        proposals = []
        
        quality_patterns = [
            {
                'pattern': r'using namespace std;',
                'title': 'Avoid using namespace std',
                'description': 'Using namespace std can lead to naming conflicts. Use specific imports instead.',
                'severity': 'low',
                'category': 'code-quality',
                'labels': ['code-quality', 'enhancement']
            },
            {
                'pattern': r'#include <bits/stdc\+\+\.h>',
                'title': 'Avoid bits/stdc++.h header',
                'description': 'bits/stdc++.h is not standard and may not be available on all systems. Use specific headers.',
                'severity': 'medium',
                'category': 'code-quality',
                'labels': ['code-quality', 'enhancement']
            }
        ]
        
        try:
            contents = self.repo.get_contents("")
            for content_file in contents:
                if content_file.type == "file" and content_file.path.endswith(('.cpp', '.c', '.h', '.hpp')):
                    try:
                        file_content = content_file.decoded_content.decode('utf-8')
                        for pattern_info in quality_patterns:
                            if re.search(pattern_info['pattern'], file_content):
                                proposals.append(IssueProposal(
                                    id=f"qual_{len(proposals) + 1}",
                                    title=pattern_info['title'],
                                    description=pattern_info['description'],
                                    severity=pattern_info['severity'],
                                    category=pattern_info['category'],
                                    file_path=content_file.path,
                                    labels=pattern_info['labels']
                                ))
                    except Exception as e:
                        print(f"Error analyzing file {content_file.path}: {e}")
        except Exception as e:
            print(f"Error accessing repository contents: {e}")
        
        return proposals
    
    def _analyze_documentation_issues(self) -> List[IssueProposal]:
        """Analyze documentation issues"""
        proposals = []
        
        # For now, return sample documentation issues
        proposals.append(IssueProposal(
            id="doc_1",
            title="Improve code documentation",
            description="The codebase would benefit from more comprehensive documentation, especially for complex functions and classes.",
            severity="low",
            category="documentation",
            labels=["documentation", "enhancement"]
        ))
        
        return proposals
    
    def _analyze_architecture_issues(self) -> List[IssueProposal]:
        """Analyze architecture issues"""
        proposals = []
        
        # For now, return sample architecture issues
        proposals.append(IssueProposal(
            id="arch_1",
            title="Implement proper error handling",
            description="The codebase needs more robust error handling mechanisms to improve reliability.",
            severity="medium",
            category="architecture",
            labels=["architecture", "enhancement"]
        ))
        
        return proposals
    
    def _generate_sample_proposals(self) -> List[IssueProposal]:
        """Generate sample issue proposals for testing"""
        return [
            IssueProposal(
                id="sample_1",
                title="Implement proper memory management in blockchain core",
                description="The blockchain core needs better memory management to prevent memory leaks in long-running operations.",
                severity="high",
                category="bug",
                file_path="src/core/blockchain.cpp",
                line_number=156,
                suggested_fix="Use smart pointers (std::unique_ptr, std::shared_ptr) instead of raw pointers",
                labels=["memory", "bug", "core"]
            ),
            IssueProposal(
                id="sample_2",
                title="Add input validation for transaction amounts",
                description="Transaction amounts should be validated to prevent negative or zero amounts.",
                severity="medium",
                category="security",
                file_path="src/core/transaction.cpp",
                line_number=89,
                suggested_fix="Add validation checks for transaction amount ranges",
                labels=["security", "validation", "transaction"]
            ),
            IssueProposal(
                id="sample_3",
                title="Improve thread safety in staking mechanism",
                description="The staking mechanism needs proper thread safety to handle concurrent staking operations.",
                severity="high",
                category="bug",
                file_path="src/core/staking.cpp",
                line_number=67,
                suggested_fix="Add mutex locks around staking operations and use atomic operations where appropriate",
                labels=["threading", "bug", "staking"]
            )
        ]
    
    def create_github_issue(self, proposal: IssueProposal) -> Optional[int]:
        """Create a GitHub issue from an approved proposal"""
        if not self.repo:
            print(f"GitHub repository not available. App ID: {self.app_id}")
            return None
        
        try:
            # Prepare issue body with Atim's signature
            body = f"""
{proposal.description}

**Analysis Details:**
- **Severity:** {proposal.severity}
- **Category:** {proposal.category}
- **Detected by:** {self.app_name}
- **Timestamp:** {datetime.now().strftime('%Y-%m-%d %H:%M:%S UTC')}

"""
            
            if proposal.file_path:
                body += f"**File:** `{proposal.file_path}`\n"
            
            if proposal.line_number:
                body += f"**Line:** {proposal.line_number}\n"
            
            if proposal.suggested_fix:
                body += f"\n**Suggested Fix:**\n```cpp\n{proposal.suggested_fix}\n```\n"
            
            body += f"\n---\n{self.app_signature}"
            
            print(f"🤖 {self.app_name} creating issue: {proposal.title}")
            print(f"Repository: {self.repo_name}")
            print(f"Labels: {proposal.labels}")
            
            # Create the issue
            issue = self.repo.create_issue(
                title=proposal.title,
                body=body,
                labels=proposal.labels
            )
            
            print(f"🤖 {self.app_name} created issue: #{issue.number}")
            
            return issue.number
            
        except GithubException as e:
            print(f"GitHub API Error creating issue: {e}")
            print(f"Error type: {type(e)}")
            print(f"Error status: {getattr(e, 'status', 'unknown')}")
            return None
        except Exception as e:
            print(f"Unexpected error creating GitHub issue: {e}")
            return None
    
    def get_repository_stats(self) -> Dict:
        """Get repository statistics"""
        if not self.repo:
            return {
                'name': self.repo_name,
                'open_issues': 0,
                'open_pulls': 0,
                'stars': 0,
                'forks': 0,
                'language': 'C++'
            }
        
        try:
            return {
                'name': self.repo.full_name,
                'open_issues': self.repo.open_issues_count,
                'open_pulls': len(list(self.repo.get_pulls(state='open'))),
                'stars': self.repo.stargazers_count,
                'forks': self.repo.forks_count,
                'language': self.repo.language or 'C++'
            }
        except GithubException as e:
            print(f"Error getting repository stats: {e}")
            return {}
    
    def get_app_info(self) -> Dict:
        """Get GitHub App information"""
        return {
            'name': self.app_name,
            'app_id': self.app_id,
            'client_id': self.client_id,
            'repository': self.repo_name,
            'description': self.app_description
        }

def create_github_integration_app() -> GitHubIntegrationApp:
    """Create GitHub integration instance using GitHub App"""
    return GitHubIntegrationApp() 